// Audio System using pre-generated ElevenLabs audio files
// Audio files are generated by scripts/generate-audio.js

class AudioManager {
    constructor() {
        this.audioCache = new Map();
        this.currentAudio = null;
        this.announcerAudio = null; // Separate channel for move announcements!
        this.enabled = true;
        this.volume = 0.7;
        this.manifest = null;
        this.manifestLoaded = false;
        
        // Shared AudioContext for synth sounds - browsers limit to ~6 contexts!
        this.synthContext = null;
        
        // Load manifest on construction
        this.loadManifest();
        
        // Voice IDs from ElevenLabs (for reference, used by generate script)
        this.voices = {
            narrator: 'pNInz6obpgDQGcFmaJgB',      // Adam - dramatic narrator
            funny: 'EXAVITQu4vr4xnSDxMaL',         // Bella - for funny sounds
            old: 'VR6AewLTigWG4xSOukaG',          // Arnold - old wise voice
            kid: 'jBpfuIE2acCO8z3wKNLl',          // Gigi - kid voice
            spuds: 'NOpBlnGInO9m6vDvFkFC',        // Spuds Oxley - verses
            mark: '3jR9BuQAOPMWUjWpi0ll',         // Mark - father voice
            brock: 'DGzg6RaUqxGRTHSBjfgF',        // Brock - spell announcements
        };
        
        // Pre-defined sound effect texts (kept for reference/fallback)
        this.soundEffects = {
            // Animal sounds
            goatBleat: ["Baaaa! Baaaa!", "Meeeeeh!", "Baaaa baaaa baaaa!"],
            catMeow: ["Meooow!", "Hissss!", "Mrrrow!"],
            dogBark: ["Woof woof woof!", "Arf arf!", "Grrrr woof!"],
            
            // Battle sounds
            attack: ["Pow!", "Wham!", "Kaboom!", "Oof!"],
            heal: ["Ahhhhh!", "Much better!", "L'chaim!"],
            shield: ["The power of Moses protects you!"],
            
            // Plague sounds
            frogs: ["Ribbit ribbit ribbit! So many frogs!", "Croak croak everywhere!"],
            locusts: ["Bzzzz! The locusts are coming!", "Bzzzzzzzz!"],
            hail: ["Kaboom! Thunder and ice!", "Crash! Bang! Hail storm!"],
            darkness: ["Everything goes dark! Oy vey!", "I can't see anything!"],
            blood: ["The waters turn red!", "Blood everywhere!"],
            
            // Kid sounds
            kidLaughing: ["Hee hee hee!", "Ha ha ha! Catch me if you can!", "Wheee!"],
            kidBump: ["Oops! Sorry!", "Watch out!", "Coming through!"],
            kidLChaim: ["L'chaim!", "L'chaim! To life!", "Mazel tov!"],
            
            // Game events
            victory: ["Mazel tov! You did it!", "Incredible! What a champion!", "The Seder is saved!"],
            defeat: ["Oy vey! You fell asleep!", "Too much wine! Zzzzz...", "Wake up! The Seder isn't over!"],
            levelComplete: ["Level complete! Yasher koach!", "Excellent work!", "On to the next verse!"],
            matzahPickup: ["Matzah! The bread of affliction gives you strength!", "Crunch crunch! Delicious matzah!"],
            
            // Hit sounds - pain reactions
            playerHit: ["Oy!", "Oy vey!", "Gevalt!", "Oy oy oy!"],
            enemyHit: ["Got 'em!", "Direct hit!", "Take that!"],
            
            // Battle pain sounds (when taking damage)
            battlePain: ["Ouch!", "Stop that!", "Oy gevalt!", "Yikes!", "Ayayay!", "That hurts!", "Oy vey iz mir!"],
            
            // Dramatic phrases
            dramatic: ["The battle begins!", "An epic confrontation!", "This is it!"],
        };
        
        // Had Gadya verses for each level
        this.verses = {
            1: "One little goat, one little goat. Which my father bought for two zuzim. One little goat, one little goat.",
            2: "Then came a cat and ate the goat, that my father bought for two zuzim. One little goat, one little goat.",
            3: "Then came a dog and bit the cat, that ate the goat, that my father bought for two zuzim. One little goat, one little goat.",
            4: "Then came a stick and beat the dog, that bit the cat, that ate the goat, that my father bought for two zuzim. One little goat, one little goat.",
            5: "Then came fire and burnt the stick, that beat the dog, that bit the cat, that ate the goat, that my father bought for two zuzim. One little goat, one little goat.",
            6: "Then came water and quenched the fire, that burnt the stick, that beat the dog, that bit the cat, that ate the goat, that my father bought for two zuzim. One little goat, one little goat.",
            7: "Then came an ox and drank the water, that quenched the fire, that burnt the stick, that beat the dog, that bit the cat, that ate the goat, that my father bought for two zuzim. One little goat, one little goat.",
            8: "Then came a slaughterer and slaughtered the ox, that drank the water, that quenched the fire, that burnt the stick, that beat the dog, that bit the cat, that ate the goat, that my father bought for two zuzim. One little goat, one little goat.",
            9: "Then came the Angel of Death and slew the slaughterer, that slaughtered the ox, that drank the water, that quenched the fire, that burnt the stick, that beat the dog, that bit the cat, that ate the goat, that my father bought for two zuzim. One little goat, one little goat.",
            10: "Then came the Holy One, blessed be He, and destroyed the Angel of Death, that slew the slaughterer, that slaughtered the ox, that drank the water, that quenched the fire, that burnt the stick, that beat the dog, that bit the cat, that ate the goat, that my father bought for two zuzim. One little goat, one little goat."
        };
        
        // Level intro announcements
        this.levelIntros = {
            1: "Level One! Father goes to market to buy a goat for two zuzim! Search those jars!",
            2: "Level Two! The cat is hungry! Chase that goat and unleash the plagues!",
            3: "Level Three! Here comes the dog! Shoot those cat spaceships with your mighty teeth!",
            4: "Level Four! The stick is angry! Roll that tank and beat that dog!",
            5: "Level Five! Fire rains from the sky! Protect the village from burning sticks!",
            6: "Level Six! Water floods the land! Navigate the dungeon and quench the flames!",
            7: "Level Seven! The mighty ox is thirsty! Drink that water, but watch out for the kids!",
            8: "Level Eight! The butcher arrives! Collect your tools before time runs out!",
            9: "Level Nine! The Angel of Death approaches! Race through the obstacles!",
            10: "Level Ten! The Final Battle! The Holy One faces the Angel of Death!"
        };
    }
    
    // Load the audio manifest
    async loadManifest() {
        try {
            // Add version + timestamp to prevent any caching (browser + CDN)
            const version = 'v2';
            const cacheBuster = `?${version}&t=${Date.now()}`;
            const response = await fetch('audio/manifest.json' + cacheBuster);
            if (response.ok) {
                this.manifest = await response.json();
                this.manifestLoaded = true;
                console.log('Audio manifest loaded successfully:', Object.keys(this.manifest));
            } else {
                console.warn('Audio manifest not found - run scripts/generate-audio.js to generate audio files');
                this.manifestLoaded = false;
            }
        } catch (error) {
            console.warn('Could not load audio manifest:', error.message);
            this.manifestLoaded = false;
        }
    }
    
    // Get audio file path from manifest with cache-busting
    getAudioPath(category, key) {
        console.log('getAudioPath called:', category, key);
        console.log('Manifest loaded:', !!this.manifest);
        if (!this.manifest) {
            console.error('Manifest not loaded!');
            return null;
        }
        if (!this.manifest[category]) {
            console.error('Category not found in manifest:', category);
            return null;
        }
        if (!this.manifest[category][key]) {
            console.error('Key not found in category:', category, key);
            console.log('Available keys:', Object.keys(this.manifest[category]));
            return null;
        }
        // Use the hash as cache buster - when voice changes, hash changes, so new file is loaded
        const fileInfo = this.manifest[category][key];
        const path = `audio/${fileInfo.file}?h=${fileInfo.hash}`;
        console.log('Returning audio path:', path);
        return path;
    }
    
    // Stub for generateSpeech - no longer used for runtime generation
    // All audio should be pre-generated using scripts/generate-audio.js
    async generateSpeech(text, voiceId = null) {
        console.warn('generateSpeech called but audio should be pre-generated. Text:', text.substring(0, 30));
        return null;
    }
    
    async play(audioUrl, volume = null) {
        console.log('play() called with URL:', audioUrl);
        if (!audioUrl || !this.enabled) {
            console.log('Play skipped - no URL or disabled. URL:', audioUrl, 'Enabled:', this.enabled);
            return;
        }
        
        // Stop current audio if playing
        if (this.currentAudio) {
            console.log('Stopping previous audio');
            this.currentAudio.pause();
        }
        
        const audio = new Audio(audioUrl);
        audio.volume = volume !== null ? volume : this.volume;
        this.currentAudio = audio;
        
        try {
            console.log('Attempting to play audio:', audioUrl);
            await audio.play();
            console.log('Audio playing successfully!');
        } catch (error) {
            console.error('Error playing audio:', error, 'URL:', audioUrl);
        }
        
        return audio;
    }
    
    async playAndWait(audioUrl, volume = null) {
        if (!this.enabled) return Promise.resolve();
        
        // If no audioUrl, try browser TTS fallback
        if (!audioUrl) {
            return Promise.resolve();
        }
        
        const audio = await this.play(audioUrl, volume);
        if (!audio) return Promise.resolve();
        
        return new Promise(resolve => {
            audio.onended = resolve;
            audio.onerror = resolve;
        });
    }
    
    // Fallback to browser's built-in speech synthesis
    speakWithBrowserTTS(text) {
        if (!this.enabled || !window.speechSynthesis) return Promise.resolve();
        
        return new Promise(resolve => {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.9;
            utterance.pitch = 1.0;
            utterance.onend = resolve;
            utterance.onerror = resolve;
            window.speechSynthesis.speak(utterance);
        });
    }
    
    // Convenience methods for common sounds
    async playRandomSound(category) {
        const sounds = this.soundEffects[category];
        if (!sounds || sounds.length === 0) return;
        
        const text = sounds[Math.floor(Math.random() * sounds.length)];
        const voiceId = category.includes('kid') ? this.voices.kid : 
                        category.includes('dramatic') ? this.voices.narrator :
                        this.voices.funny;
        
        const audioUrl = await this.generateSpeech(text, voiceId);
        return this.play(audioUrl);
    }
    
    async playVerse(levelNumber) {
        console.log('playVerse called for level:', levelNumber);
        if (!this.enabled) {
            console.log('Audio disabled, skipping verse');
            return Promise.resolve();
        }
        
        // Wait for manifest to load if not ready
        if (!this.manifestLoaded && !this.manifest) {
            console.log('Waiting for manifest to load...');
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // Try to use pre-generated audio file
        const audioPath = this.getAudioPath('verses', levelNumber.toString());
        console.log('Audio path:', audioPath);
        if (audioPath) {
            console.log('Playing pre-generated verse:', audioPath);
            return this.playAndWait(audioPath);
        }
        
        // Fallback to browser TTS if no pre-generated audio
        console.warn('Verse audio not found, using browser TTS fallback');
        const verse = this.verses[levelNumber];
        if (!verse) return Promise.resolve();
        return this.speakWithBrowserTTS(verse);
    }
    
    async playLevelIntro(levelNumber) {
        const intro = this.levelIntros[levelNumber];
        if (!intro) return;
        
        const audioUrl = await this.generateSpeech(intro, this.voices.narrator);
        return this.play(audioUrl);
    }
    
    async playAnimalSound(animal) {
        if (!this.enabled) return;
        
        // Map animal to category and pick random variant
        const animalMap = {
            'goat': { category: 'animals', keys: ['goat1', 'goat2', 'goat3'] },
            'cat': { category: 'animals', keys: ['cat1', 'cat2', 'cat3'] },
            'dog': { category: 'animals', keys: ['dog1', 'dog2', 'dog3'] }
        };
        
        const config = animalMap[animal];
        if (!config) return;
        
        // Pick random variant
        const key = config.keys[Math.floor(Math.random() * config.keys.length)];
        const audioPath = this.getAudioPath(config.category, key);
        
        if (audioPath) {
            return this.play(audioPath);
        }
        
        // Fallback to old method
        const categoryMap = { 'goat': 'goatBleat', 'cat': 'catMeow', 'dog': 'dogBark' };
        return this.playRandomSound(categoryMap[animal] || 'goatBleat');
    }
    
    async playGoatSound() {
        return this.playAnimalSound('goat');
    }
    
    async playCatSound() {
        return this.playAnimalSound('cat');
    }
    
    async playDogSound() {
        return this.playAnimalSound('dog');
    }
    
    // Play zuz finding messages
    async playZuzMessage(key) {
        if (!this.enabled) return;
        
        const audioPath = this.getAudioPath('zuz', key);
        if (audioPath) {
            return this.play(audioPath, 0.9);
        }
        
        // Fallback to browser TTS
        const messages = {
            'found1': 'I found one zuz! Need one more.',
            'found2': 'Found two zuzim, enough for a goat!'
        };
        return this.speakWithBrowserTTS(messages[key] || key);
    }
    
    async playBattleSound(type) {
        if (!this.enabled) return;
        
        // Map type to battle audio keys
        const battleMap = {
            'attack': ['attack1', 'attack2', 'attack3', 'attack4'],
            'heal': ['heal1', 'heal2', 'heal3'],
            'shield': ['shield1', 'shield2'],
            'block': ['shield1', 'shield2'],
            'pain': ['pain1', 'pain2', 'pain3']
        };
        
        const keys = battleMap[type] || battleMap['attack'];
        const key = keys[Math.floor(Math.random() * keys.length)];
        const audioPath = this.getAudioPath('battle', key);
        
        if (audioPath) {
            return this.play(audioPath);
        }
        
        // Fallback
        const category = type === 'heal' ? 'heal' : type === 'shield' || type === 'block' ? 'shield' : 'attack';
        return this.playRandomSound(category);
    }
    
    async playAttackSound() {
        return this.playBattleSound('attack');
    }
    
    async playHealSound() {
        return this.playBattleSound('heal');
    }
    
    async playShieldSound() {
        return this.playBattleSound('shield');
    }
    
    async playPlagueSound(plague) {
        const plagueMap = {
            'frogs': 'frogs',
            'locusts': 'locusts', 
            'hail': 'hail',
            'darkness': 'darkness',
            'blood': 'blood'
        };
        
        const category = plagueMap[plague] || 'attack';
        return this.playRandomSound(category);
    }
    
    async playRandomKidPhrase() {
        const categories = ['kidLaughing', 'kidBump', 'kidLChaim'];
        const category = categories[Math.floor(Math.random() * categories.length)];
        return this.playRandomSound(category);
    }
    
    async playKidSound() {
        const categories = ['kidLaughing', 'kidBump', 'kidLChaim'];
        const category = categories[Math.floor(Math.random() * categories.length)];
        return this.playRandomSound(category);
    }
    
    async playVictory() {
        return this.playRandomSound('victory');
    }
    
    async playDefeat() {
        return this.playRandomSound('defeat');
    }
    
    async playLevelComplete() {
        return this.playRandomSound('levelComplete');
    }
    
    async playMatzahPickup() {
        return this.playRandomSound('matzahPickup');
    }
    
    async playPlayerHit() {
        return this.playRandomSound('playerHit');
    }
    
    async playEnemyHit() {
        return this.playRandomSound('enemyHit');
    }
    
    async playDramatic() {
        return this.playRandomSound('dramatic');
    }
    
    async playBattlePain() {
        return this.playRandomSound('battlePain');
    }
    
    // Announce move name like Mortal Kombat announcer - dramatic sergeant voice!
    // Uses a SEPARATE audio channel so it doesn't get interrupted by battle sounds!
    async announceMove(moveName) {
        if (!this.enabled) return;
        
        // Try to find pre-generated move audio
        const moveKey = this.getMoveKey(moveName);
        if (moveKey) {
            const audioPath = this.getAudioPath('moves', moveKey);
            if (audioPath) {
                return this.playAnnouncer(audioPath, 0.9);
            }
        }
        
        // Fallback to API
        const dramaticName = moveName.toUpperCase() + "!";
        const audioUrl = await this.generateSpeech(dramaticName, this.voices.narrator);
        return this.playAnnouncer(audioUrl, 0.9);
    }
    
    // Separate play method for announcer audio - doesn't interrupt regular audio!
    async playAnnouncer(audioUrl, volume = null) {
        if (!audioUrl || !this.enabled) {
            console.log('Announcer play skipped - no URL or disabled');
            return;
        }
        
        // Stop previous announcer audio if playing (but NOT regular audio)
        if (this.announcerAudio) {
            this.announcerAudio.pause();
        }
        
        const audio = new Audio(audioUrl);
        audio.volume = volume !== null ? volume : this.volume;
        this.announcerAudio = audio;
        
        try {
            console.log('Announcer playing:', audioUrl);
            await audio.play();
        } catch (error) {
            console.error('Error playing announcer audio:', error);
        }
        
        return audio;
    }
    
    // Map move names to pre-generated audio keys
    getMoveKey(moveName) {
        const moveMap = {
            'Matzah Slap': 'move1',
            'Shofar Blast': 'move2',
            'Dreidel Spin': 'move3',
            'Chicken Soup': 'move4',
            'Hora Dance': 'move5',
            'Gefilte Fish': 'move6',
            'Latke Spin': 'move7',
            'Blood': 'move8',
            'Frogs': 'move9',
            'Lice': 'move10',
            'Wild Beasts': 'move11',
            'Pestilence': 'move12',
            'Boils': 'move13',
            'Hail': 'move14',
            'Locusts': 'move15',
            'Darkness': 'move16',
            'Burning Bush': 'move17'
        };
        return moveMap[moveName];
    }
    
    async sayText(text, voice = 'narrator') {
        const voiceId = this.voices[voice] || this.voices.narrator;
        const audioUrl = await this.generateSpeech(text, voiceId);
        return this.play(audioUrl);
    }
    
    // Synthesized sound effects using Web Audio API (doesn't interrupt speech!)
    playSynthSound(type) {
        // Reuse shared AudioContext to avoid browser limits (max ~6 contexts)
        if (!this.synthContext || this.synthContext.state === 'closed') {
            this.synthContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const ctx = this.synthContext;
        
        // Resume if suspended (happens after user interaction requirement)
        if (ctx.state === 'suspended') {
            ctx.resume();
        }
        
        if (type === 'vaseBreak') {
            // Crash/shatter sound - noise burst with decay
            const duration = 0.3;
            const bufferSize = ctx.sampleRate * duration;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                // White noise with quick decay
                const decay = Math.exp(-i / (bufferSize * 0.1));
                data[i] = (Math.random() * 2 - 1) * decay;
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 2000;
            
            const gain = ctx.createGain();
            gain.gain.value = 0.4;
            
            source.connect(filter);
            filter.connect(gain);
            gain.connect(ctx.destination);
            source.start();
            
        } else if (type === 'coinPickup') {
            // Cha-ching! Rising tones
            const osc1 = ctx.createOscillator();
            const osc2 = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc1.type = 'sine';
            osc2.type = 'sine';
            osc1.frequency.value = 800;
            osc2.frequency.value = 1200;
            
            osc1.frequency.setValueAtTime(800, ctx.currentTime);
            osc1.frequency.linearRampToValueAtTime(1200, ctx.currentTime + 0.1);
            osc2.frequency.setValueAtTime(1200, ctx.currentTime + 0.1);
            osc2.frequency.linearRampToValueAtTime(1600, ctx.currentTime + 0.2);
            
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
            
            osc1.connect(gain);
            osc2.connect(gain);
            gain.connect(ctx.destination);
            
            osc1.start();
            osc2.start(ctx.currentTime + 0.1);
            osc1.stop(ctx.currentTime + 0.15);
            osc2.stop(ctx.currentTime + 0.3);
            
        } else if (type === 'splash') {
            // Water splash - filtered noise
            const duration = 0.4;
            const bufferSize = ctx.sampleRate * duration;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                const decay = Math.exp(-i / (bufferSize * 0.2));
                data[i] = (Math.random() * 2 - 1) * decay;
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 800;
            
            const gain = ctx.createGain();
            gain.gain.value = 0.3;
            
            source.connect(filter);
            filter.connect(gain);
            gain.connect(ctx.destination);
            source.start();
            
        } else if (type === 'hit') {
            // Impact sound
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.1);
            
            gain.gain.setValueAtTime(0.4, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.15);
            
        } else if (type === 'bark') {
            // Quick dog bark
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(250, ctx.currentTime + 0.08);
            osc.frequency.setValueAtTime(450, ctx.currentTime + 0.1);
            osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.18);
            
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.4, ctx.currentTime + 0.05);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.2);
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.2);
            
        } else if (type === 'meow') {
            // Cat meow/hit sound
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(900, ctx.currentTime + 0.1);
            osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.25);
            
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.3);
            
        } else if (type === 'throw') {
            // Throwing/whoosh sound
            const bufferSize = ctx.sampleRate * 0.2;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                const t = i / bufferSize;
                const decay = Math.sin(t * Math.PI);
                data[i] = (Math.random() * 2 - 1) * decay * 0.3;
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(500, ctx.currentTime);
            filter.frequency.linearRampToValueAtTime(2000, ctx.currentTime + 0.2);
            filter.Q.value = 2;
            
            source.connect(filter);
            filter.connect(ctx.destination);
            source.start();
            
        } else if (type === 'slurp') {
            // Drinking/slurping sound
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            const filter = ctx.createBiquadFilter();
            
            osc.type = 'sawtooth';
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(400, ctx.currentTime);
            filter.Q.value = 10;
            
            // Warble the frequency for slurping effect
            osc.frequency.setValueAtTime(100, ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(200, ctx.currentTime + 0.05);
            osc.frequency.linearRampToValueAtTime(80, ctx.currentTime + 0.1);
            osc.frequency.linearRampToValueAtTime(180, ctx.currentTime + 0.15);
            osc.frequency.linearRampToValueAtTime(100, ctx.currentTime + 0.2);
            
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.25);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.25);
            
        } else if (type === 'fire') {
            // Fire crackling
            const duration = 0.3;
            const bufferSize = ctx.sampleRate * duration;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                const t = i / bufferSize;
                data[i] = (Math.random() * 2 - 1) * Math.random() * (1 - t) * 0.4;
            }
            
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 1000;
            
            source.connect(filter);
            filter.connect(ctx.destination);
            source.start();
            
        } else if (type === 'explosion') {
            // Explosion/big impact
            const osc = ctx.createOscillator();
            const noise = ctx.createBufferSource();
            const gain = ctx.createGain();
            
            // Create noise buffer
            const bufferSize = ctx.sampleRate * 0.5;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
            }
            noise.buffer = buffer;
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(100, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.3);
            
            gain.gain.setValueAtTime(0.5, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            
            osc.connect(gain);
            noise.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            noise.start();
            osc.stop(ctx.currentTime + 0.5);
            
        } else if (type === 'powerup') {
            // Power up / collect sound
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.1);
            osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.2);
            
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.25);
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.25);
            
        } else if (type === 'laser') {
            // Laser/projectile sound
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.15);
            
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.15);
            
        } else if (type === 'death') {
            // Death/defeat sound
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.8);
            
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 1);
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 1);
            
        } else if (type === 'chomp') {
            // Chomping/eating sound - quick percussive bite
            const osc = ctx.createOscillator();
            const noise = ctx.createBufferSource();
            const gain = ctx.createGain();
            
            // Create short noise burst for the crunch
            const bufferSize = ctx.sampleRate * 0.15;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.05));
            }
            noise.buffer = buffer;
            
            // Low thump for the bite
            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.1);
            
            gain.gain.setValueAtTime(0.4, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1500;
            
            osc.connect(gain);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            noise.start();
            osc.stop(ctx.currentTime + 0.15);
            
        } else if (type === 'snore') {
            // Snoring sound - oscillating low frequency with breathing pattern
            const duration = 1.5;
            const osc = ctx.createOscillator();
            const osc2 = ctx.createOscillator();
            const gain = ctx.createGain();
            const lfo = ctx.createOscillator();
            const lfoGain = ctx.createGain();
            
            // Main snore tone - low rumble
            osc.type = 'sawtooth';
            osc.frequency.value = 80;
            
            // Second oscillator for texture
            osc2.type = 'triangle';
            osc2.frequency.value = 120;
            
            // LFO for the "breathing" wavering
            lfo.type = 'sine';
            lfo.frequency.value = 3; // 3 Hz wobble
            lfoGain.gain.value = 30;
            
            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);
            
            // Envelope - breathe in, breathe out pattern
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.15, ctx.currentTime + 0.3);
            gain.gain.linearRampToValueAtTime(0.2, ctx.currentTime + 0.6);
            gain.gain.linearRampToValueAtTime(0.1, ctx.currentTime + 1.0);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 300;
            
            osc.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(ctx.destination);
            
            lfo.start();
            osc.start();
            osc2.start();
            lfo.stop(ctx.currentTime + duration);
            osc.stop(ctx.currentTime + duration);
            osc2.stop(ctx.currentTime + duration);
            
        } else if (type === 'versus') {
            // Epic 80's style VS announcement sound
            // Deep dramatic hit with rising synth
            const osc1 = ctx.createOscillator();
            const osc2 = ctx.createOscillator();
            const osc3 = ctx.createOscillator();
            const noise = ctx.createBufferSource();
            const gain = ctx.createGain();
            const gain2 = ctx.createGain();
            
            // Create impact noise
            const bufferSize = ctx.sampleRate * 0.8;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
            }
            noise.buffer = buffer;
            
            // Deep bass hit
            osc1.type = 'sine';
            osc1.frequency.setValueAtTime(60, ctx.currentTime);
            osc1.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.5);
            
            // Rising synth
            osc2.type = 'sawtooth';
            osc2.frequency.setValueAtTime(100, ctx.currentTime);
            osc2.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.3);
            
            // High accent
            osc3.type = 'square';
            osc3.frequency.setValueAtTime(800, ctx.currentTime + 0.1);
            osc3.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.2);
            
            // Main gain envelope
            gain.gain.setValueAtTime(0.5, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.8);
            
            // Second gain for high synth
            gain2.gain.setValueAtTime(0, ctx.currentTime);
            gain2.gain.linearRampToValueAtTime(0.2, ctx.currentTime + 0.1);
            gain2.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 2000;
            
            osc1.connect(gain);
            osc2.connect(filter);
            filter.connect(gain);
            noise.connect(gain);
            osc3.connect(gain2);
            gain.connect(ctx.destination);
            gain2.connect(ctx.destination);
            
            osc1.start();
            osc2.start();
            osc3.start(ctx.currentTime + 0.1);
            noise.start();
            osc1.stop(ctx.currentTime + 0.8);
            osc2.stop(ctx.currentTime + 0.5);
            osc3.stop(ctx.currentTime + 0.3);
        }
    }
    
    // Victory announcements with sergeant voice for each level
    async announceVictory(levelNumber) {
        console.log('announceVictory called for level:', levelNumber);
        if (!this.enabled) {
            console.log('Audio disabled, skipping victory');
            return;
        }
        
        // Wait for manifest to load if not ready
        if (!this.manifestLoaded && !this.manifest) {
            console.log('Waiting for manifest to load for victory...');
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // Try to use pre-generated victory audio
        const audioPath = this.getAudioPath('victory', levelNumber.toString());
        console.log('Victory audio path:', audioPath);
        if (audioPath) {
            console.log('Playing pre-generated victory:', audioPath);
            return this.play(audioPath, 0.9);
        }
        
        console.warn('Victory audio path not found for level:', levelNumber);
        
        // Fallback to browser TTS
        const victoryPhrases = {
            1: "Father bought the goat for two zuzim!",
            2: "The cat ate the goat!",
            3: "The dog bit the cat!",
            4: "The stick beat the dog!",
            5: "Fire burnt the stick!",
            6: "Water quenched the fire!",
            7: "The ox drank the water!",
            8: "The butcher slaughtered the ox!",
            9: "The Angel of Death killed the butcher!",
            10: "The Holy One, Blessed be He, destroyed the Angel of Death! Enjoy your Seder!"
        };
        
        const phrase = victoryPhrases[levelNumber];
        if (phrase) {
            console.warn('Victory audio not found, using browser TTS fallback');
            return this.speakWithBrowserTTS(phrase);
        }
    }
    
    // Game over announcement with Brock voice
    async playGameOver(reason = '') {
        console.log('playGameOver called with reason:', reason);
        if (!this.enabled) return;
        
        // Wait for manifest to load if not ready
        if (!this.manifestLoaded && !this.manifest) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // Map reason text to pre-generated audio key
        let audioKey = 'default';
        const reasonLower = reason.toLowerCase();
        if (reasonLower.includes('asleep') || reasonLower.includes('awakeness')) {
            audioKey = 'asleep';
        } else if (reasonLower.includes('caught')) {
            audioKey = 'caught';
        } else if (reasonLower.includes('eaten') || reasonLower.includes('ate')) {
            audioKey = 'eaten';
        } else if (reasonLower.includes('burn') || reasonLower.includes('fire')) {
            audioKey = 'burned';
        } else if (reasonLower.includes('drown') || reasonLower.includes('water')) {
            audioKey = 'drowned';
        } else if (reasonLower.includes('kill') || reasonLower.includes('death') || reasonLower.includes('slaughter')) {
            audioKey = 'killed';
        } else if (reasonLower.includes('lost') || reasonLower.includes('defeat') || reasonLower.includes('battle')) {
            audioKey = 'lost';
        } else if (reasonLower.includes('time') || reasonLower.includes('timeout')) {
            audioKey = 'timeout';
        }
        
        // Try to use pre-generated game over audio
        const audioPath = this.getAudioPath('gameover', audioKey);
        console.log('Game over audio path:', audioPath);
        if (audioPath) {
            return this.play(audioPath, 0.9);
        }
        
        // Fallback to browser TTS
        console.warn('Game over audio not found, using browser TTS fallback');
        return this.speakWithBrowserTTS('Game over! Better luck next time!');
    }
    
    stop() {
        if (this.currentAudio) {
            this.currentAudio.pause();
            this.currentAudio = null;
        }
        // Also stop snoring
        this.stopSnoring();
    }
    
    // Snoring sound that plays continuously with variable volume
    startSnoring(volume = 0.3) {
        if (!this.enabled) return;
        if (this.snoreInterval) return; // Already snoring
        
        this.snoreVolume = volume;
        this.playSnoreOnce();
        
        // Play snore sound every 2 seconds
        this.snoreInterval = setInterval(() => {
            if (this.snoreVolume > 0) {
                this.playSnoreOnce();
            }
        }, 2000);
    }
    
    playSnoreOnce() {
        if (!this.enabled || this.snoreVolume <= 0) return;
        
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const duration = 1.5;
        const osc = ctx.createOscillator();
        const osc2 = ctx.createOscillator();
        const gain = ctx.createGain();
        const lfo = ctx.createOscillator();
        const lfoGain = ctx.createGain();
        
        // Main snore tone
        osc.type = 'sawtooth';
        osc.frequency.value = 70 + Math.random() * 20;
        
        osc2.type = 'triangle';
        osc2.frequency.value = 110 + Math.random() * 20;
        
        // LFO for wobble
        lfo.type = 'sine';
        lfo.frequency.value = 2.5 + Math.random();
        lfoGain.gain.value = 25;
        
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        
        // Breathing envelope scaled by volume
        const vol = this.snoreVolume * 0.4;
        gain.gain.setValueAtTime(0, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(vol * 0.7, ctx.currentTime + 0.3);
        gain.gain.linearRampToValueAtTime(vol, ctx.currentTime + 0.6);
        gain.gain.linearRampToValueAtTime(vol * 0.5, ctx.currentTime + 1.0);
        gain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);
        
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 250;
        
        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);
        
        lfo.start();
        osc.start();
        osc2.start();
        lfo.stop(ctx.currentTime + duration);
        osc.stop(ctx.currentTime + duration);
        osc2.stop(ctx.currentTime + duration);
    }
    
    updateSnoreVolume(volume) {
        this.snoreVolume = Math.max(0, Math.min(1, volume));
    }
    
    stopSnoring() {
        if (this.snoreInterval) {
            clearInterval(this.snoreInterval);
            this.snoreInterval = null;
        }
        this.snoreVolume = 0;
    }
    
    setVolume(vol) {
        this.volume = Math.max(0, Math.min(1, vol));
        if (this.currentAudio) {
            this.currentAudio.volume = this.volume;
        }
    }
    
    toggleEnabled() {
        this.enabled = !this.enabled;
        if (!this.enabled) {
            this.stop();
            if (window.musicPlayer) {
                window.musicPlayer.stop();
            }
        }
        return this.enabled;
    }
}

// Chad Gadya Music Player using Web Audio API
class ChadGadyaMusic {
    constructor() {
        this.audioContext = null;
        this.isPlaying = false;
        this.playbackRate = 1.0;
        this.volume = 0.15;
        this.currentTimeout = null;
        this.noteIndex = 0;
        
        // Note frequencies (Hz)
        this.noteFreqs = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
            'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
            'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46,
            'G5': 783.99, 'A5': 880.00
        };
        
        // Chad Gadya melody based on the traditional tune
        // Each note: [noteName, duration in beats]
        this.melody = [
            // "Chad gad-ya, chad gad-ya"
            ['E4', 1], ['E4', 0.5], ['F4', 0.5], ['G4', 1], ['G4', 1],
            ['G4', 0.5], ['A4', 0.5], ['G4', 0.5], ['F4', 0.5], ['E4', 1],
            // "di-za-bin ab-ba bi-trei zu-zei"
            ['D4', 0.5], ['E4', 0.5], ['F4', 0.5], ['G4', 0.5],
            ['A4', 0.5], ['A4', 0.5], ['G4', 0.5], ['F4', 0.5],
            ['E4', 1], ['D4', 1], ['C4', 2],
            // Repeat with variation
            ['E4', 1], ['E4', 0.5], ['F4', 0.5], ['G4', 1], ['G4', 1],
            ['A4', 0.5], ['G4', 0.5], ['F4', 0.5], ['E4', 0.5], ['D4', 1],
            ['E4', 0.5], ['F4', 0.5], ['G4', 0.5], ['A4', 0.5],
            ['G4', 0.5], ['F4', 0.5], ['E4', 0.5], ['D4', 0.5],
            ['C4', 1], ['D4', 0.5], ['E4', 0.5], ['C4', 2]
        ];
        
        this.baseTempo = 180; // BPM
    }
    
    init() {
        if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
    }
    
    playNote(frequency, duration, startTime) {
        if (!this.audioContext) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        // Use a nice warm sound
        oscillator.type = 'triangle';
        oscillator.frequency.value = frequency;
        
        // Envelope for nicer sound
        const now = this.audioContext.currentTime + startTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(this.volume, now + 0.05);
        gainNode.gain.setValueAtTime(this.volume, now + duration * 0.7);
        gainNode.gain.linearRampToValueAtTime(0, now + duration);
        
        oscillator.start(now);
        oscillator.stop(now + duration);
    }
    
    play() {
        if (this.isPlaying) return;
        
        this.init();
        this.isPlaying = true;
        this.noteIndex = 0;
        this.scheduleNextNote();
    }
    
    scheduleNextNote() {
        if (!this.isPlaying) return;
        
        const note = this.melody[this.noteIndex];
        const [noteName, beats] = note;
        const frequency = this.noteFreqs[noteName];
        const tempo = this.baseTempo * this.playbackRate;
        const duration = (beats * 60) / tempo;
        
        this.playNote(frequency, duration * 0.9, 0);
        
        this.noteIndex = (this.noteIndex + 1) % this.melody.length;
        
        this.currentTimeout = setTimeout(() => {
            this.scheduleNextNote();
        }, duration * 1000);
    }
    
    stop() {
        this.isPlaying = false;
        if (this.currentTimeout) {
            clearTimeout(this.currentTimeout);
            this.currentTimeout = null;
        }
    }
    
    setSpeed(rate) {
        // Clamp between 0.5x and 2.5x speed
        this.playbackRate = Math.max(0.5, Math.min(2.5, rate));
    }
    
    setVolume(vol) {
        this.volume = Math.max(0, Math.min(1, vol));
    }
}

// ==============================================================
// TITLE SCREEN MUSIC - Dramatic 80's Mortal Kombat Style!
// ==============================================================
class TitleMusic {
    constructor() {
        this.audioContext = null;
        this.isPlaying = false;
        this.volume = 0.25;
        this.nodes = [];
        this.intervals = [];
        this.beatIndex = 0;
    }
    
    init() {
        if (!this.audioContext || this.audioContext.state === 'closed') {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.audioContext.state === 'suspended') {
            this.audioContext.resume();
        }
    }
    
    play() {
        if (this.isPlaying) return;
        
        this.init();
        this.isPlaying = true;
        this.beatIndex = 0;
        
        const ctx = this.audioContext;
        
        // Master gain
        this.masterGain = ctx.createGain();
        this.masterGain.gain.value = this.volume;
        this.masterGain.connect(ctx.destination);
        
        // Start the epic music layers
        this.playBassLine();
        this.playDrums();
        this.playLead();
        this.playPad();
    }
    
    playBassLine() {
        const ctx = this.audioContext;
        // Dark, menacing bass pattern in E minor
        const bassNotes = [82.41, 82.41, 98.00, 82.41, 73.42, 82.41, 110.00, 98.00]; // E2, E2, G2, E2, D2, E2, A2, G2
        let noteIndex = 0;
        
        const playBassNote = () => {
            if (!this.isPlaying) return;
            
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            const filter = ctx.createBiquadFilter();
            
            osc.type = 'sawtooth';
            osc.frequency.value = bassNotes[noteIndex % bassNotes.length];
            
            filter.type = 'lowpass';
            filter.frequency.value = 200;
            filter.Q.value = 5;
            
            gain.gain.setValueAtTime(0.4, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.18);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            
            osc.start();
            osc.stop(ctx.currentTime + 0.2);
            
            noteIndex++;
        };
        
        playBassNote();
        const bassInterval = setInterval(playBassNote, 200); // 150 BPM feel
        this.intervals.push(bassInterval);
    }
    
    playDrums() {
        const ctx = this.audioContext;
        let beat = 0;
        
        const playDrumHit = () => {
            if (!this.isPlaying) return;
            
            const beatInMeasure = beat % 8;
            
            // Kick on 1, 3, 5, 7 (every other beat)
            if (beatInMeasure % 2 === 0) {
                this.playKick();
            }
            
            // Snare on 2 and 6
            if (beatInMeasure === 2 || beatInMeasure === 6) {
                this.playSnare();
            }
            
            // Hi-hat on every beat
            this.playHiHat(beatInMeasure % 2 === 1);
            
            beat++;
        };
        
        playDrumHit();
        const drumInterval = setInterval(playDrumHit, 200);
        this.intervals.push(drumInterval);
    }
    
    playKick() {
        const ctx = this.audioContext;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.1);
        
        gain.gain.setValueAtTime(0.7, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start();
        osc.stop(ctx.currentTime + 0.15);
    }
    
    playSnare() {
        const ctx = this.audioContext;
        
        // Noise burst for snare
        const bufferSize = ctx.sampleRate * 0.1;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
        }
        
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        
        const filter = ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.5, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        noise.start();
    }
    
    playHiHat(open = false) {
        const ctx = this.audioContext;
        
        const bufferSize = ctx.sampleRate * (open ? 0.1 : 0.05);
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.05));
        }
        
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        
        const filter = ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 7000;
        
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.15, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + (open ? 0.1 : 0.05));
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        noise.start();
    }
    
    playLead() {
        const ctx = this.audioContext;
        // Dramatic lead melody - dark and menacing
        // E minor pentatonic riff
        const leadPattern = [
            { freq: 329.63, dur: 0.3 },  // E4
            { freq: 392.00, dur: 0.15 }, // G4
            { freq: 440.00, dur: 0.15 }, // A4
            { freq: 493.88, dur: 0.6 },  // B4
            { freq: 440.00, dur: 0.3 },  // A4
            { freq: 392.00, dur: 0.3 },  // G4
            { freq: 329.63, dur: 0.6 },  // E4
            { freq: 293.66, dur: 0.3 },  // D4
            { freq: 329.63, dur: 0.6 },  // E4
            { freq: 0, dur: 0.3 },       // Rest
        ];
        
        let noteIndex = 0;
        let nextNoteTime = ctx.currentTime + 0.8; // Start after intro
        
        const scheduleNote = () => {
            if (!this.isPlaying) return;
            
            const note = leadPattern[noteIndex % leadPattern.length];
            
            if (note.freq > 0) {
                const osc = ctx.createOscillator();
                const osc2 = ctx.createOscillator();
                const gain = ctx.createGain();
                const filter = ctx.createBiquadFilter();
                
                // Detuned oscillators for thick sound
                osc.type = 'sawtooth';
                osc.frequency.value = note.freq;
                osc2.type = 'square';
                osc2.frequency.value = note.freq * 1.005; // Slight detune
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(800, ctx.currentTime + note.dur);
                filter.Q.value = 2;
                
                gain.gain.setValueAtTime(0, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.2, ctx.currentTime + 0.02);
                gain.gain.setValueAtTime(0.2, ctx.currentTime + note.dur - 0.05);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + note.dur);
                
                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                osc2.start();
                osc.stop(ctx.currentTime + note.dur + 0.01);
                osc2.stop(ctx.currentTime + note.dur + 0.01);
            }
            
            noteIndex++;
            nextNoteTime += note.dur;
        };
        
        const leadInterval = setInterval(() => {
            if (!this.isPlaying) return;
            scheduleNote();
        }, 300);
        
        this.intervals.push(leadInterval);
        scheduleNote(); // Start first note
    }
    
    playPad() {
        const ctx = this.audioContext;
        
        // Dark atmospheric pad - E minor chord
        const padFreqs = [164.81, 196.00, 246.94]; // E3, G3, B3
        
        const oscNodes = [];
        const gainNode = ctx.createGain();
        const filter = ctx.createBiquadFilter();
        
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        filter.Q.value = 1;
        
        gainNode.gain.setValueAtTime(0, ctx.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.08, ctx.currentTime + 1);
        
        padFreqs.forEach(freq => {
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = freq;
            osc.connect(filter);
            osc.start();
            oscNodes.push(osc);
            
            // Add slight vibrato with LFO
            const lfo = ctx.createOscillator();
            const lfoGain = ctx.createGain();
            lfo.type = 'sine';
            lfo.frequency.value = 4 + Math.random();
            lfoGain.gain.value = 2;
            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);
            lfo.start();
            oscNodes.push(lfo);
        });
        
        filter.connect(gainNode);
        gainNode.connect(this.masterGain);
        
        this.nodes.push(...oscNodes, gainNode, filter);
    }
    
    stop() {
        this.isPlaying = false;
        
        // Clear all intervals
        this.intervals.forEach(interval => clearInterval(interval));
        this.intervals = [];
        
        // Fade out master gain
        if (this.masterGain && this.audioContext) {
            const ctx = this.audioContext;
            this.masterGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
        }
        
        // Stop and disconnect nodes after fade
        setTimeout(() => {
            this.nodes.forEach(node => {
                try {
                    if (node.stop) node.stop();
                    node.disconnect();
                } catch (e) {}
            });
            this.nodes = [];
        }, 400);
    }
    
    setVolume(vol) {
        this.volume = Math.max(0, Math.min(1, vol));
        if (this.masterGain) {
            this.masterGain.gain.value = this.volume;
        }
    }
}

// Create global title music player
window.titleMusic = new TitleMusic();

// Create global music player
window.musicPlayer = new ChadGadyaMusic();

// Create global audio manager instance
window.audioManager = new AudioManager();

// Initialize audio on page load
document.addEventListener('DOMContentLoaded', async () => {
    console.log(' Audio Manager initialized!');
    console.log(' Chad Gadya Music Player ready!');
    console.log(' All audio is pre-generated - ready to play!');
});
